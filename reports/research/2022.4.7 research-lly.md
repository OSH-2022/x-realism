# Research-Microkernel

## 前言

- 此为第二次调研，主要调研微内核方面
- 为适配调研报告格式，提前适配了标题层级，方便后续整合。

## 项目背景

### 微内核和宏内核

本部分简述微内核的基本特点，并比较两种内核架构 [ysy 部分](2022.4.5&#32;research-ysy.md)

### 微内核

本部分具体调研微内核领域内的相关项目以及面临的问题，例如分析微内核架构怎么搭, 会放什么模块, 微内核的主流做法

问题：IPC 开销（属于分布式开销）

#### MINIX

Minix，是一个采用微内核的迷你版本的类 Unix 操作系统，由塔能鲍姆教授为了教学之用而创作。它也影响了 Linux 内核的开发。

全套 Minix 除了启动的部分以汇编语言编写以外，其他大部分都是 C 语言编写。分为：内核、存储器管理及文件系统三部分。

文件系统与存储器管理作为模块，不是在操作系统核心中运作，而是在用户空间运作。至 Minix 3 时，IO 设备也被移到用户空间运作。此外，由于 Minix 主要用于教学，因此代码简洁，可读性较强。

从[MINIX 3](https://en.wikipedia.org/wiki/MINIX_3)开始，开发的主要目标从教育转移到创建[高度可靠](https://en.wikipedia.org/wiki/High_availability)和[自我修复的](https://en.wikipedia.org/wiki/Self-management_(computer_science))微内核操作系统

#### Mach

Mach 由 CMU 开发，也是第一代微内核架构的操作系统，主要是出于研究目的被开发出来，特別是在分布式与并行计算上。

Mach 按以下几个概念作为其基础：

- “任务” 即拥有一组系统资源的对象，允许“线程”在其中执行。
- “[线程](https://zh.wikipedia.org/wiki/线程)” 是执行的基本单位，拥有一个任务的上下文，并且共享任务中的资源。
- “port” 是任务间通讯的一组受保护的消息队列；任务可以对任何port发送或接收数据。
- “消息” 是某些有类型的数据对象的集合，它们只可以发送至port - 而非某特定任务或线程。

但作为第一代微内核系统， Mach 的性能并不好：这一方面是因为 IPC 的开销，另外一方面也是因为频繁的上下文切换

这最终导致一些在 Mach 基础上继续改进的操作系统实现上将很影响时间的文件系统模块和驱动模块移动到了内核内部，一定程度上违背了微内核的设计哲学

#### L4

> L4 是一种微内核构架的操作系统内核，最初由约亨·李德克（Jochen Liedtke）设计，前身为 L3 微内核。在最开始，L4 只是一个由约亨·李德克设计并实现的单一的产品，用于 Intel i386 上的一个高度优化内核。L4微内核系统由于其出色的性能和很小的体积而开始被计算机工业所认知。随后，L4 的系统在多个方面上有了高速的发展，值得提及的是一个更加独立于硬件平台的版本，被称为 Pistachio，之后又被移植到了许多不同的硬件构架上。现在已经形成一个微内核家族，包括 Pistachio，L4/MIPS，与 Fiasco。

后序发展上，L4 主要用于类 Unix、可移植操作系统接口( POSIX ) 兼容类型。

L4 秉承极简，高效和安全的设计理念：

- 相对于 Mach, Mach 的 ipc 运行缓慢的一个很重要原因是 ipc 代码段过大，会发生较多 L1 cache miss，很影响时间。这启发了微内核的一个设计逻辑： **微内核本身必须充分小**
  - 为此，L4 以及它的前身 L3 的很多代码采用汇编语言编写
- L4 微内核仅提供以下基本概念的抽象
  - 地址空间 (抽象出页表，并提供内存保护)
  - 线程和调度 (抽象出代码执行过程，并提供时间上的保护)
  - IPC 通信 (用于跨越不同（进程）的抽象边界，进行受控的通信)

##### IPC

相比较 Mach 采取异步的利用内核缓冲区进行进程间通信的策略，L4 使用同步 IPC，这意味着一个集合通信模型，当发送者和接收者都准备好时交换消息。如果两者都在同一个内核上运行，这意味着其中一个将阻塞，直到另一个调用 IPC 操作。

在 L4 中，IPC 通过 “端点对象”。端点可以被认为是一个邮箱，发送者和接收者通过该邮箱通过握手交换消息。任何拥有 Send 能力的人都可以通 Endpoint 发送消息，任何拥有 Receive 上限的人都可以接收消息。这意味着每个端点可以有任意数量的发送者和接收者。特别是，无论有多少线程尝试从 Endpoint 接收，特定消息仅传递给一个接收者（队列中的第一个接收者）。

#### seL4

##### 项目简介

seL4 是 L4 微内核家族的一员，着重强化了 L4 内核的安全性

seL4 的形式验证使其有别于任何其他操作系统。简而言之，它在系统中运行的应用程序之间提供了最高的 *隔离* 保证，这意味着可以控制系统某个部分的妥协并防止损害系统的其他可能更关键的部分。

具体来说，seL4 的实现在形式上通过不同层次的接口的抽象以及每一层次的状态机形式验证被证明是正确的，并且如果配置正确，它的操作也已被证明在最坏情况下执行时间具有安全上限。它是世界上第一个具有这种证明的操作系统，并且仍然是唯一一个经过验证的具有基于细粒度能力的安全性和高性能的操作系统。它还为 [混合临界实时系统](https://en.wikipedia.org/wiki/Mixed_criticality) 提供最先进的支持。

##### 特性

###### 地址空间

内核在引导到第一个用户进程（称为“根任务”）后，通过将相应的上限存放在根任务的 Cspace 中，将所有空闲内存（称为“未类型化”）交给用户空间来控制系统资源。然后根任务可以实施其资源管理策略，例如通过将系统划分为安全域并将每个域交给一个不相交的无类型内存子集。

用户空间可直接访问的唯一对象是“框架对象”：这些对象可以被映射到页表，之后用户空间可以写入由这些框架对象表示的物理内存。

简而言之，seL4 将内核资源的管理导出到用户级别，并使它们受到与用户资源相同的基于能力的访问控制。

###### 线程通信

通信可以通过 IPC 或共享内存进行。IPC 通常应用于短消息，不长于几百字节的消息大小，这是依赖实现定义和体系结构的限制，但通常消息应该保持在几十个字节。对于较长的消息，应使用共享缓冲区。

共享缓冲区访问可以通过通知机制同步。

##### L4 相关思想

1. **规范**：也即前文的形式上(功能上)的正确性证明
2. **最小化**：这是微内核的核心思想。seL4 在内核中没有设备驱动程序（除了中断控制器和计时器），内存管理采用极端方法，甚至内核内存也由用户级代码管理。
3. **性能**：这是 seL4 的核心驱动力
   - 关注代码的关键路径（实际上类似 Amdahl 定律，某些操作比其他操作更频繁地使用，并且可以通过将成本从经常使用的“热”操作转移到不经常使用的操作来最大化整体性能。）
   - 不要为不使用的东西买单。(有些功能即使不使用它也是有代价的：进行额外检查的性能成本，异常处理的复杂性成本。)
4. **安全**：安全性实际上也是一个核心原则，内核从根本上是为提供尽可能强的隔离而设计的，同时也要注意不能让安全性称为降低性能的借口。

#### RT-Thread Smart

而 RT-Thread Smart 定位于成为一个面向实时应用场合的高性能混合微内核操作系统，以期填补传统 RTOS 和大型操作系统之间的留白。

RT-Thread Smart 上，使用了共享内存的方式，把交换的数据内存块，分别投到不同的进程地址空间上，从而不需要做额外的数据拷贝。

共享内存的方式进一步降低了 IPC 通信的成本。

由于采用共享内存， RT-Thread Smart 主要面向带 MMU（Memory Management Unit，内存管理单元）的中高端处理器，为众多领域提供更具竞争力的操作系统基础软件平台，具备快速启动、POSIX 接口全兼容等特性。

[说明文档](https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-smart/rt-smart-quickstart/rt-smart-quickstart)

##### 共享内存通信

当数据在保护域之间复制时，它会从源位置复制到内核内存区域的临时存储中，然后再复制到目标位置。对于大量数据，这些复制操作占据了大部分通信时间。为了使通信更快，应避免复制操作。 L4 微内核通过使源位置在目标保护域中可见（在内核内存区域内）消除了一次复制操作。因此，消息可以从源位置直接复制到目标位置。但是，临时映射的成本会影响整体通信成本。此外，通信的源需要将消息的参数复制到消息缓冲区中，而目标需要将参数从消息缓冲区中复制出来。

避免这些复制操作的一种机制是共享内存通信。无需将数据复制到消息缓冲区，然后将消息缓冲区从发送方复制到接收方，最后再将数据从消息缓冲区中复制出来，消息缓冲区可以位于发送方和接收方共享的内存区域中。需要注意的是，必须同步对此共享消息缓冲区的访问以避免数据损坏

此外，当使用共享内存通信时，我们在保护域中有一系列应用程序处理相同的数据。由于数据处理是顺序的，因此一次只能有一个应用程序对数据具有写访问权。通常建议将可写的共享内存区域映射到仅一个应用程序。当下一个应用程序应该处理数据时，必须转移写入共享内存区域的权限。





#### Fuchsia

Fuchsia 是谷歌开发的基于能力的开源操作系统。在 Google 的基于 Linux 的操作系统（如 Chrome OS 和 Android）之后，Fuchsia 基于名为 Zircon 的独特内核。它于 2016 年 8 月作为自托管 git 存储库公开亮相，没有任何官方公司公告。经过多年的发展，它的正式产品发布在第一代 Google Nest Hub 上，取代了原来的 Cast OS。

Fuchsia 基于一种新的消息传递内核，以矿物锆石命名为 Zircon。它的代码库源自嵌入式设备的 Little Kernel (LK)，旨在为各种设备提供低资源使用。 LK 由 Travis Geiselbrecht 开发，他也是 Haiku 使用的 NewOS 内核的共同作者。那是 BeOS 的免费软件重新实现，它是由 Erich Ringewald 在 1990 年代设计的, 1988 年 Apple 的 Pink 的原始首席设计师。

Fuchsia 作为一个实时操作系统，内核是 Zircon ，采用的也是微内核架构。事实上，很多像 Fuchsia 和 FreeRTOS 这样的实时操作系统采用的都是微内核架构，微内核的结构更为小巧，也更容易对每个模块分别维护更新，这也使得它更能适应高度定制化的嵌入式设备的内核开发

## 参考资料

https://en.wikipedia.org/wiki/Mach_(kernel)

https://en.wikipedia.org/wiki/L4_microkernel_family

https://en.wikipedia.org/wiki/Minix

https://zhuanlan.zhihu.com/p/216408256

https://os.inf.tu-dresden.de/papers_ps/aigner_phd.pdf

https://en.wikipedia.org/wiki/Fuchsia_(operating_system)#Kernel